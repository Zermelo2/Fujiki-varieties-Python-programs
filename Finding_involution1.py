from sympy.combinatorics.perm_groups import PermutationGroup
from sympy.combinatorics.permutations import Permutation
from itertools import combinations
from sympy.combinatorics.named_groups import SymmetricGroup

#theta is defined via conjugation by an element T.

def theta(M,T):
    return T*M*(T**-1)



#The group G is obtained as a subgroup of S_n generated by a list of elements L.
#The next function runs in a list P and returns the elements in P which provide
#automorphisms on G by conjugation. These automorphisms are put in list A.

def The_Automorphisms(L,P):
    l=len(L)
    G=PermutationGroup(L)                    #Defintion of G.
    A=[]
    k=len(P)
    for j in range(0,k):
        a=True                              #a will test if P[j] defines an automorphism of G.
        for m in range(0,l):
            a=a*(P[j]*L[m]*P[j]**-1 in G)    #We test that all generators of G is sent in G
        if a:                                #by conjugation by P[j].
            A=A+[P[j]]                       #If a=true, we add P[j] to the list A.
    return A                                 #A is the list of elements in P which
                                             #provide automorphisms on G via conjugation.



#The next function find the elements in P which provide trivial automorphism on G;
#they are put in list A. This is important to express the automorphism group of G. 

def The_Automorphisms_trivial(L,P):
   l=len(L)
   G=PermutationGroup(L)                    
   A=[]
   k=len(P)
   for j in range(0,k):
        N=[]                            #N will be the image of P[j]                    
        for m in range(0,l):
            N=N+[P[j]*L[m]*P[j]**-1]    #We compute the image of the generators
        if N==L:                        #We check if the action on the generators is trivial.        
            A=A+[P[j]]                       
   return A      



#For a given theta, the next function determines the set F defined in Notation 4.8.
#It corresponds to the elements g in G which are sent to g^{-1} by theta.


def surfaces_fixes(L,T):                    #T defines theta by conjugation.
    G=PermutationGroup(L)
    M=G._elements
    n=len(M)
    F=[]
    for i in range(0,n):
        if theta(M[i],T)==M[i]**-1:         #We check the condition to be in F
            F=F+[M[i]]
    return F




#The next function determines the valid involutions obtained by conjugation after
#an embedding of G in the permutation group S_n.

def valid_involution(L,n):                 
    Pv=[]                               #Pv will be the list of valid involutions.
    G=PermutationGroup(L)               #Definition of G.
    K=SymmetricGroup(n)                 #G is embedded in K=S_n.
    k=int(n/2)                      #We are going to construct all the order 2 elements in K.
    for i in range(0,k+1):      #i is half the lenght of the support of an order 2 element.
        T=Permutation(n-1)
        for j in range(0,2*i,2):        #Constuction of an order 2 element of lenght 2i.
            T=T*Permutation(j,j+1)
        R=list(K.conjugacy_class(T))    #R contains all the order 2 elements  of lenght 2i.
        R=The_Automorphisms(L,R)        #We restrict to the order 2 elements which provide
        for j in range(0,len(R)):       #involutions on G.
            F=surfaces_fixes(L,R[j])    
            H=PermutationGroup(F)       #We test if the involution if valid.
            if H.order()==G.order():
                Pv=Pv+[R[j]]            #The valid involutions are put in the list Pv.
    return Pv




#The next function provides the list modulo equivalence of valid involutions obtained
#by conjugation via elements in S_n. It is based on Proposition 3.26.
#N is a list of generators for the group G tilde in Proposition 3.26.
#We start with some valid involutions in P. Each time that the assumptions of 
#Proposition 3.26 are verified for two involutions, we keep only one of the both. 
#The result will be given in the list Pv.

def classes_valid_involution(L,N,P,n):
    Gtilde=PermutationGroup(N)                  
    G=PermutationGroup(L)                        
    M=Gtilde._elements                          
    P2=[]
    k=len(L)                                    #We only consider the elements of Gtilde
    if L!=N:                                    #which act on G by conjugation.
        M=The_Automorphisms(L,M)                #The elements h1 and h2 of Proposition 3.26
    while P!=[]:                                #will be searched in the list M.
        I=P[0]                                  
        P.remove(P[0])                          #We will test that the involution I:=P[0] is 
        LL=[]                                   #not already equivalent to an involution of P2.
        a=True
        j=0
        for i in range(0,k):                    #We compute the image of the generators of G
           LL=LL+[theta(L[i],I)]                #by theta_I.
        while a==True and j<len(P2):            
            m1=0
            while a==True and m1<len(M):        #The elements M[m1] and M[m2] correspond to
                m2=0                            #the elements h_1 and h_2 of Proposition 3.26.
                while a==True and m2<len(M):    #We test the condition of Proposition 3.26 for 
                    LP=[]                       #theta_I and theta_{P2[j]}.
                    Q=M[m1]*M[m2]**-1
                    if theta(Q,I)==Q**-1 and (Q in G):
                        for l in range(0,k):
                            R=theta(M[m1],I)
                            LP=LP+[R**-1*M[m2]*theta(L[l],P2[j])*M[m2]**-1*R]
                        a=a*(LP!=LL)
                    m2=m2+1
                m1=m1+1
            j=j+1
        if a:                                   #If the conditions of Proposition 3.26 
            P2=P2+[I]                           #are never verified, we add I to the list P2.
    return P2                                    



#L is a family of generators of G, N a family of generators of H,
#A and B are the two valid involutions that we want to compare.
#The variable r is the cardinal that we want for the group G tilde.
#The next program will provide an element P
#such that the group G tilde is generated by G and P.

def finding_G_tilde(L,N,A,B,r):
    l=len(L)
    H=PermutationGroup(N)
    G=PermutationGroup(L)
    N=G._elements
    n=len(N)
    h2=H._elements
    m=len(h2)
    HH=[]
    for k in range(0,n):                        #We construct the list HH
        if theta(N[k],B)==N[k]**-1:         #of the elements h_1*h_2**-1 
            HH=HH+[N[k]]                        #as in Proposition 3.26.
    f=len(HH)
    for i in range(0,m):
        for j in range(0,f):
            h1=HH[j]*h2[i]
            b=True
            for x in range(0,l):                    #we search for h1 and h2 that
                left=theta(h1*L[x]*h1**-1,B)    #verified Proposition 3.26.
                right=h2[i]*theta(L[x],A)*h2[i]**-1
                b=b*(left==right)
            if b:
                K=PermutationGroup(L+[h2[i]])        #We construct G tilde.
                if (K.order()==r):
                    return h2[i]
    







